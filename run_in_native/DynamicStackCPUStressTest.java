import java.util.concurrent.*;
import java.lang.reflect.Method;

/**
 * Simplified Dynamic Stack CPU Stress Test
 *
 * This test uses pre-generated classes to create deep call stacks for CPU sampling analysis.
 * Classes are generated by the bash script for much better performance.
 *
 * Call stack example with depth 4:
 * main -> DynamicStressClass0_1.call() -> DynamicStressClass0_2.call() ->
 * DynamicStressClass0_3.call() -> DynamicStressClass0_4.call() -> native work()
 */
public class DynamicStackCPUStressTest {
    static { System.loadLibrary("cpustress"); }

    public native void work(int threadId, int seconds);

    public DynamicStackCPUStressTest() {
        // Simple constructor - no complex initialization needed
    }

    /**
     * Execute the stress test by calling the first class in the chain for the given thread
     */
    public void executeTest(int stackDepth, int threadId, int totalDuration, int nativeDuration, int restartFrequency) throws Exception {
        // Call the first class in the chain for this thread
        String firstClassName = "DynamicStressClass" + threadId + "_1";

        try {
            Class<?> firstClass = Class.forName(firstClassName);
            Method callMethod = firstClass.getMethod("call",
                DynamicStackCPUStressTest.class, int.class, int.class);

            long startTime = System.currentTimeMillis();
            long endTime = startTime + (totalDuration * 1000L);

            if (nativeDuration >= totalDuration) {
                // Single call for entire duration (original behavior)
                callMethod.invoke(null, this, threadId, totalDuration);
            } else {
                // Chunked execution: call native method repeatedly with nativeDuration chunks
                int callCount = 0;
                int restartCount = 0;
                while (System.currentTimeMillis() < endTime) {
                    long remainingTime = (endTime - System.currentTimeMillis()) / 1000L;
                    int currentChunkDuration = (int) Math.min(nativeDuration, remainingTime);

                    if (currentChunkDuration <= 0) {
                        break;
                    }

                    callCount++;
                    callMethod.invoke(null, this, threadId, currentChunkDuration);

                    // Check if we need to restart this thread (simulate thread restart)
                    if (restartFrequency > 0 && (callCount % restartFrequency) == 0) {
                        restartCount++;
                        System.out.println("Thread " + threadId + ": Restarting after " + callCount + " calls (restart #" + restartCount + ")");

                        // Simulate thread restart by sleeping briefly and creating a new thread context
                        Thread.sleep(10); // Slightly longer pause to simulate restart overhead

                        // Force class reloading to simulate a fresh thread context
                        firstClass = Class.forName(firstClassName);
                        callMethod = firstClass.getMethod("call",
                            DynamicStackCPUStressTest.class, int.class, int.class);
                    } else {
                        // Small pause between chunks to ensure we return to Java
                        Thread.sleep(1);
                    }
                }
                if (restartFrequency > 0) {
                    System.out.println("Thread " + threadId + ": Completed " + callCount + " native chunks with " + restartCount + " restarts");
                } else {
                    System.out.println("Thread " + threadId + ": Completed " + callCount + " native chunks");
                }
            }
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Class " + firstClassName + " not found. " +
                "Make sure the bash script generated all required classes.", e);
        }
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 1) {
            System.err.println("Usage: DynamicStackCPUStressTest <stackDepth> [duration] [threads] [nativeDuration] [restartFrequency]");
            System.err.println("  restartFrequency: restart threads every N native calls (0 = no restarts, default: 0)");
            return;
        }

        int stackDepth = Integer.parseInt(args[0]);
        int duration = args.length > 1 ? Integer.parseInt(args[1]) : 10;
        int threads = args.length > 2 ? Integer.parseInt(args[2]) : Runtime.getRuntime().availableProcessors();
        int nativeDuration = args.length > 3 ? Integer.parseInt(args[3]) : duration; // Default to entire duration
        int restartFrequency = args.length > 4 ? Integer.parseInt(args[4]) : 0; // Default: no restarts

        if (stackDepth < 1) {
            System.err.println("Stack depth must be at least 1");
            return;
        }

        if (nativeDuration > duration) {
            System.err.println("Native duration cannot be longer than total duration");
            return;
        }

        if (restartFrequency < 0) {
            System.err.println("Restart frequency must be 0 or positive");
            return;
        }

        System.out.println("Starting Dynamic Stack CPU Stress Test:");
        System.out.println("  Stack depth: " + stackDepth);
        System.out.println("  Duration: " + duration + " seconds");
        System.out.println("  Threads: " + threads);
        System.out.println("  CPU cores: " + Runtime.getRuntime().availableProcessors());
        if (nativeDuration < duration) {
            System.out.println("  Native call duration: " + nativeDuration + " seconds (chunked execution)");
        } else {
            System.out.println("  Native call duration: entire test duration");
        }
        if (restartFrequency > 0) {
            System.out.println("  Thread restart frequency: every " + restartFrequency + " native calls");
        } else {
            System.out.println("  Thread restart frequency: disabled");
        }

        DynamicStackCPUStressTest test = new DynamicStackCPUStressTest();
        ExecutorService executor = Executors.newFixedThreadPool(threads);

        try {
            // Use a CountDownLatch to synchronize thread start
            CountDownLatch startLatch = new CountDownLatch(1);
            CountDownLatch doneLatch = new CountDownLatch(threads);

            // Submit tasks for all threads
            for (int t = 0; t < threads; t++) {
                final int threadId = t;
                executor.submit(() -> {
                    try {
                        // Wait for all threads to be ready
                        startLatch.await();

                        // Execute the test with pre-generated classes
                        test.executeTest(stackDepth, threadId, duration, nativeDuration, restartFrequency);

                    } catch (Exception e) {
                        System.err.println("Thread " + threadId + " failed: " + e.getMessage());
                        e.printStackTrace();
                    } finally {
                        doneLatch.countDown();
                    }
                });
            }

            // Start all threads simultaneously
            System.out.println("Starting all threads...");
            long testStartTime = System.currentTimeMillis();
            startLatch.countDown();

            // Wait for completion with timeout
            boolean completed = doneLatch.await(duration + 10, TimeUnit.SECONDS);
            long testEndTime = System.currentTimeMillis();

            if (!completed) {
                System.err.println("Test did not complete within expected time, forcing shutdown...");
                executor.shutdownNow();
            } else {
                System.out.println("Test completed in " + (testEndTime - testStartTime) / 1000.0 + " seconds");
            }

        } finally {
            executor.shutdown();
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        }
    }
}
